using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class LayoutGenerator : MonoBehaviour {
	// editor testing only
	public Texture2D inputTexture;

	// camera and image info
	private Camera _camera;
	private Texture2D _screenShot;
	[HideInInspector]
	public int resWidth;
	[HideInInspector]
	public int resHeight;
	private int brightnessLimit = 20;

	// mesh generation info
	public int wallHeight;
	public GameObject spriteForColliderGeneration;
	public GameObject layout;
	private int meshLoop;
	private PolygonCollider2D colliderComponent;
	private List<Vector3> vertices;
	private List<int> triangles;
	private Vector3 lowCloseLeftPoint = new Vector3(10000, 10000, 10000);
	private Vector3 lowFarRightPoint = new Vector3(-10000, -10000, 10000);

	// Use this for initialization
	void Awake () 
	{
		_camera = Camera.main;
		resWidth = _camera.pixelWidth;
		resHeight = _camera.pixelHeight;
	}

	// Generates a level layout from the dark lines drawn on camera
	public void GenerateLayout() 
	{
		// take screenshot of the camera view
		Debug.Log("Starting Screenshot Coroutine");
		StartCoroutine(TakeScreenShot());
	}
	
	// Creates a sprite/texture from the camera view
	public IEnumerator TakeScreenShot()
	{
		yield return new WaitForEndOfFrame();

		// create a rendertexture from the mainCamera and cast it to a Texture2D
		RenderTexture rt = new RenderTexture(resWidth, resHeight, 24);
		_camera.targetTexture = rt;
		_screenShot= new Texture2D(resWidth, resHeight, TextureFormat.ARGB32, false);
		_camera.Render();
		RenderTexture.active = rt;
		_screenShot.ReadPixels(new Rect(0, 0, resWidth, resHeight), 0, 0);

		// isolate the dark pixels from the screenshot
		Color[] c = _screenShot.GetPixels();
		c = IsolateDarkPixels(c);
		_screenShot.SetPixels(0, 0, resWidth, resHeight, c);
		_screenShot.Apply();

		// remove the rendertexture
		_camera.targetTexture = null;
		RenderTexture.active = null;
		Destroy(rt);

		ProcessTexture2D(_screenShot);
	}

	// Processes a sprite/Texture2D into a 3D model
	public void ProcessTexture2D(Texture2D tex) {
		// assign sprite to spriterenderer and add a PolygonCollider2D to autogenerate the collider
		Sprite tempSprite = Sprite.Create(tex,new Rect(0,0,resWidth,resHeight),new Vector2(0,0));
		SpriteRenderer spriteComponent = spriteForColliderGeneration.GetComponent<SpriteRenderer>();
		spriteComponent.sprite = tempSprite;
		Debug.LogFormat("x bounds: {0}, y bounds: {1}", spriteComponent.bounds.size.x, spriteComponent.bounds.size.y);
		Debug.LogFormat("scaled x bounds: {0}, scaled y bounds: {1}", spriteComponent.bounds.size.x*spriteComponent.transform.localScale.x, spriteComponent.bounds.size.y*spriteComponent.transform.localScale.y);
		spriteForColliderGeneration.transform.localPosition = new Vector3(-spriteComponent.bounds.size.y/2, wallHeight*0.03f, -spriteComponent.bounds.size.x/2); 
		//spriteForColliderGeneration.transform.position -= new Vector3(0.0725f, 0, 0.045f); 
		colliderComponent = spriteForColliderGeneration.AddComponent<PolygonCollider2D>();

		Debug.Log("Screenshot taken");

		// build the mesh data
		vertices = new List<Vector3>();
		triangles = new List<int>();
		BrowseColliderToCreateMesh(colliderComponent);

		// add the floor
		/*Debug.Log(lowCloseLeftPoint.ToString() + lowFarRightPoint.ToString());
		GameObject floor = GameObject.CreatePrimitive(PrimitiveType.Cube);
		floor.transform.SetParent(spriteForColliderGeneration.transform, false);
		//floor.transform.localScale = spriteComponent.bounds.size;
		floor.transform.localScale = lowFarRightPoint - lowCloseLeftPoint;
		floor.transform.localPosition += new Vector3(floor.transform.localScale.x/2, floor.transform.localScale.y/2, wallHeight);*/

		// apply mesh data to create final mesh 
		Mesh layoutMeshFilterMesh = layout.GetComponent<MeshFilter>().mesh;
		layoutMeshFilterMesh.vertices = vertices.ToArray();
		layoutMeshFilterMesh.triangles = triangles.ToArray();

		// add this mesh to the MeshCollider
		layout.GetComponent<MeshCollider>().sharedMesh = layoutMeshFilterMesh;
	}

	// Browses the collider autogenerated from our texture and launches MakeMesh
	public void BrowseColliderToCreateMesh (PolygonCollider2D collider){
		// browse all paths from collider
		int pathCount = collider.pathCount;
		meshLoop = 0;
		for (int i = 0; i < pathCount; i++)
		{
			Vector2[] path = collider.GetPath(i);
			Vector3 point0;
			Vector3 point1;
			Vector3 point2;
			Vector3 point3;

			// browse all path points, drawing lines between sets
			for (int j = 1; j < path.Length; j++)
			{
				if (j != (path.Length - 1)) // if we aren't at the last point
				{
					point0 = new Vector3(path[j-1].x, path[j-1].y, 0);
					point1 = new Vector3(path[j-1].x, path[j-1].y, wallHeight);
					point2 = new Vector3(path[j].x, path[j].y, wallHeight);
					point3 = new Vector3(path[j].x, path[j].y, 0);
					
					AnalyzePoints(new Vector3[] {point0, point1, point2, point3});
					MakeMesh(point0, point1, point2, point3);

				} 
				else if(j == (path.Length - 1))// if we are at the last point, we need to close the loop with the first point
				{
					point0 = new Vector3(path[j-1].x, path[j-1].y, 0);
					point1 = new Vector3(path[j-1].x, path[j-1].y, wallHeight);
					point2 = new Vector3(path[j].x, path[j].y, wallHeight);
					point3 = new Vector3(path[j].x, path[j].y, 0);

					AnalyzePoints(new Vector3[] {point0, point1, point2, point3});
					MakeMesh(point0, point1, point2, point3);

					// back to first point
					point0 = new Vector3(path[j].x, path[j].y, 0);
					point1 = new Vector3(path[j].x, path[j].y, wallHeight);
					point2 = new Vector3(path[0].x, path[0].y, wallHeight); // First point
					point3 = new Vector3(path[0].x, path[0].y, 0); 			// First point

					MakeMesh(point0, point1, point2, point3);
				}
			}
		}
	}

	// Analyzes groups of points to find overall metrics
	private void AnalyzePoints(Vector3[] points) {
		// find corners of bottom plane
		foreach(Vector3 point in points) 
		{
			if (point.x <= lowCloseLeftPoint.x && point.y <= lowCloseLeftPoint.y && point.z <= lowCloseLeftPoint.z)
				lowCloseLeftPoint = point;
			if (point.x >= lowFarRightPoint.x && point.y >= lowFarRightPoint.y && point.z <= lowFarRightPoint.z)
				lowFarRightPoint = point;
		}
	}

	// Generates two triangle meshes from the four given points and adds them to the meshcollider
	private void MakeMesh(Vector3 p0,Vector3 p1,Vector3 p2, Vector3 p3)
	{
		// TODO will a screen to world point conversion size down appropriately?
		
		// add vertices
		vertices.Add(p0);
		vertices.Add(p1);
		vertices.Add(p2);
		vertices.Add(p3);

		// add triangles
		// triangle 1
		triangles.Add(0+meshLoop*4);
		triangles.Add(2+meshLoop*4);
		triangles.Add(1+meshLoop*4);
		// triangle 2
		triangles.Add(0+meshLoop*4);
		triangles.Add(3+meshLoop*4);
		triangles.Add(2+meshLoop*4);

		// iterate
		meshLoop += 1;
	}

	// Maps a float from one range to another
	private static float MapToRange(float pIn, float from1, float from2, float to1, float to2) 
	{
		return (pIn - from1) / (to1 - from1) * (to2 - from2) + from2;
	}

	// Calculates the relative brightness of a given color value
	private static int Brightness(Color c)
	{
		float red = MapToRange(c.r, 0, 1, 0, 255);
		float green = MapToRange(c.g, 0, 1, 0, 255);
		float blue = MapToRange(c.b, 0, 1, 0, 255);

		return (int)Mathf.Sqrt((float)(
			red * red * 0.241 + 
			green * green * 0.691 + 
			blue * blue * 0.068));
	}

	// Isolates pixels with low brightness, removing bright pixels from the array
	public Color[] IsolateDarkPixels(Color[] pC) 
	{
		List<Color> outputColor = new List<Color>();
		foreach(Color c in pC) 
		{
			if(Brightness(c) < brightnessLimit)
			{
				outputColor.Add(Color.white);
				continue;
			}
			outputColor.Add(Color.clear);
		}

		return outputColor.ToArray();
	}
}
